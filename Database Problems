



 (ORDER BY id)  AS prev
    FROM logs
    ) tb1
WHERE num = next AND next = prev

Time/Efficiency:533 ms
Note:
-Lead over partrition by and lag over partrition by 
 lead() to extract the next row of number
 lag() to extract the pre row of number

Solution 2.1:
with cte as 
(SELECT Num,
LEAD(Num,1) over (order by id) as first_lead,
LEAD(Num,2) over (order by id) as second_lead
from logs)

select distinct Num as ConsecutiveNums
from cte
where Num = first_lead and first_lead = second_lead

Solution3: 
Select distinct Num as ConsecutiveNums
from Logs
where (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)

Date: Dec 16 2021
178. Rank Scores
Write an SQL query to rank the scores. The ranking should be calculated according to the following rules:
The scores should be ranked from the highest to the lowest.
If there is a tie between two scores, both should have the same ranking.
After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.
My solution(wrong):
SELECT Score, rank(Score) over (order by id ) AS ranking 
FROM Scores 
ORDER BY Score

Solution1:
SELECT score, dense_rank() over (order by score DESC) as 'rank'
FROM Scores

Note:
1. dense_rank/rank/row_number的用法区别： https://blog.csdn.net/u011726005/article/details/94592866
2. over（）括号里面应该排序，而不是在末尾加orderby
3. rank涉及keyword，因此要加引号

184. Department Highest Salary
Write an SQL query to find employees who have the highest salary in each of the departments.

My solution(wrong):
with cte as(SELECT rank() over(Partrition by Department order by salary DESC) as rank1
FROM Employee e
JOIN Department d
ON e.departmentId=d.id                              
) a

SELECT d.name AS Department, e.name AS Employee, e.salary as Salary
FROM Employee e
JOIN Department d
ON e.departmentId=d.id
WHERE a.rank1=1

My solution(correct)
select Department,Employee,Salary
from(
SELECT d.name AS Department, e.name AS Employee, e.salary as Salary, 
rank() over(partition by d.name order by e.salary DESC) as rn
FROM Employee e
JOIN Department d
ON e.departmentId=d.id
) a
where rn=1

Runtime: 502 ms
Notes:
-typo error: partition by 
-window function cannot be used in where clause

185. Department Top Three Salaries
My solution(correct)
select Department,Employee,Salary
from(
SELECT d.name AS Department, e.name AS Employee, e.salary as Salary, 
dense_rank() over(partition by d.name order by e.salary DESC) as rn
FROM Employee e
JOIN Department d
ON e.departmentId=d.id
) a
where rn<=3
Runtime: 149 ms

?question:为什么用rank不能accept，结果是一样的

1511. Customer Order Frequency
Write an SQL query to report the customer_id and customer_name of customers who have spent at least $100 in each month of June and July 2020.
My answer(wrong):
SELECT c.customer_id,c.name, sum(quantity*price) as total
FROM customers c
JOIN orders o ON c.customer_id=o.customer_id 
JOIN product p ON p.product_id=o.product_id
Where substring(order_date,5,2) in ('06','07') 
Group by customer_id,name
having total>=100

Notes:
1.having/where/group by的顺序
2.如何提取日期的月份，天，以及年

solution1:
SELECT customer_id, name
FROM (
    SELECT c.customer_id, c.name, 
    SUM(CASE WHEN LEFT(o.order_date, 7) = '2020-06' THEN p.price*o.quantity ELSE 0 END) AS t1, 
    SUM(CASE WHEN LEFT(o.order_date, 7) = '2020-07' THEN p.price*o.quantity ELSE 0 END) AS t2
    FROM customers c
    JOIN orders o
    ON c.customer_id = o.customer_id
    JOIN product p
    ON p.product_id = o.product_id
    GROUP BY 1
    ) tmp
WHERE t1 >= 100 AND t2 >= 100

？question：为什么这里只group by 1个量，不是应该除了sum之外都需要被group by吗？
notes：
1.使用left来截取日期函数





 
 














