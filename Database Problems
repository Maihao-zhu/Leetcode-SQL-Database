Date: Dec 09 2021
177. Nth Highest Salary
Write an SQL query to report the nth highest salary from the Employee table. If there is no nth highest salary, the query should report null.
My solution 
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
Declare m INT; 
set m=n-1;

  RETURN (
      # Write your MySQL query statement below.
      Select salary
      From Employee
      Group by salary 
      order by salary Desc
      Limit m,1
      
  );
END

Time/Efficiency:359 ms
Note:
-Limit(offset,count)
-Limit and order count from row0

Date: Dec 15 2021
180. Consecutive numbers
Write an SQL query to find all numbers that appear at least three times consecutively.
My solution(wrong):
select num
from logs
where count(num)>3
Solution1: self-join
select distinct a.num as ConsecutiveNums
from logs a join logs b
on a.id=b.id+1 and a.num=b.num
Join logs c
on a.id=c.id+2 and a.num=c.num

Time/Efficiency:388 ms
Note:
-Format: 
 SELECT/FROM/ON need to use capital letters
 line 1: select/from 
 line 2: join on and 
-When it comes to compare with themselves/find consecutive numbers, need to use self-join.
-Everytime，when finishing writting code, need to look back and sort the logic to see if anything else need to be added in the query: eg. distinct

Solution2: window functions 
SELECT DISTINCT num AS ConsecutiveNums
FROM (
    SELECT num,
        LEAD(num) OVER (ORDER BY id)  AS next,
        LAG(num) OVER (ORDER BY id)  AS prev
    FROM logs
    ) tb1
WHERE num = next AND next = prev

Time/Efficiency:533 ms
Note:
-Lead over partrition by and lag over partrition by 
 lead() to extract the next row of number
 lag() to extract the pre row of number

Solution 2.1:
with cte as 
(SELECT Num,
LEAD(Num,1) over (order by id) as first_lead,
LEAD(Num,2) over (order by id) as second_lead
from logs)

select distinct Num as ConsecutiveNums
from cte
where Num = first_lead and first_lead = second_lead

Solution3: 
Select distinct Num as ConsecutiveNums
from Logs
where (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)

Date: Dec 16 2021
178. Rank Scores
Write an SQL query to rank the scores. The ranking should be calculated according to the following rules:
The scores should be ranked from the highest to the lowest.
If there is a tie between two scores, both should have the same ranking.
After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.
My solution(wrong):
SELECT Score, rank(Score) over (order by id ) AS ranking 
FROM Scores 
ORDER BY Score

Solution1:
SELECT score, dense_rank() over (order by score DESC) as 'rank'
FROM Scores

Note:
1. dense_rank/rank/row_number的用法区别： https://blog.csdn.net/u011726005/article/details/94592866
2. over（）括号里面应该排序，而不是在末尾加orderby
3. rank涉及keyword，因此要加引号

184. Department Highest Salary
Write an SQL query to find employees who have the highest salary in each of the departments.

My solution(wrong):
with cte as(SELECT rank() over(Partrition by Department order by salary DESC) as rank1
FROM Employee e
JOIN Department d
ON e.departmentId=d.id                              
) a

SELECT d.name AS Department, e.name AS Employee, e.salary as Salary
FROM Employee e
JOIN Department d
ON e.departmentId=d.id
WHERE a.rank1=1

My solution(correct)
select Department,Employee,Salary
from(
SELECT d.name AS Department, e.name AS Employee, e.salary as Salary, 
rank() over(partition by d.name order by e.salary DESC) as rn
FROM Employee e
JOIN Department d
ON e.departmentId=d.id
) a
where rn=1

Runtime: 502 ms
Notes:
-typo error: partition by 
-window function cannot be used in where clause





 
 














